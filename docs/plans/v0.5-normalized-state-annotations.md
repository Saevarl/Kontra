# v0.5 — Normalized State & Run Annotations

## Overview

This release normalizes the state schema (replacing JSONB blobs with queryable tables) and adds run annotations — a mechanism for agents/consumers to record context about validation runs without affecting Kontra's behavior.

**Key principle:** Annotations give agents "memory without authority."

---

## Part 1: Normalized State Schema

### Current State (v0.4.x)

```sql
CREATE TABLE kontra_state (
    id SERIAL PRIMARY KEY,
    contract_fingerprint TEXT NOT NULL,
    contract_name TEXT NOT NULL,
    run_at TIMESTAMPTZ NOT NULL,
    passed BOOLEAN NOT NULL,
    -- ... summary columns ...
    state JSONB NOT NULL  -- ← full results blob
);
```

**Problems:**
- Rule results buried in JSONB — hard to query
- Can't easily ask "show all runs where COL:email:not_null failed"
- Foreign keys for annotations need rule-level IDs

### New Schema

#### Table: `kontra_runs`

Run-level metadata. One row per validation run.

```sql
CREATE TABLE kontra_runs (
    id SERIAL PRIMARY KEY,

    -- Identity
    contract_fingerprint TEXT NOT NULL,
    contract_name TEXT NOT NULL,
    dataset_fingerprint TEXT,
    dataset_name TEXT,

    -- Timing
    run_at TIMESTAMPTZ NOT NULL,
    duration_ms INT,

    -- Summary
    passed BOOLEAN NOT NULL,
    total_rows BIGINT,
    total_rules INT NOT NULL,
    passed_rules INT NOT NULL,
    failed_rules INT NOT NULL,

    -- By severity
    blocking_failures INT NOT NULL DEFAULT 0,
    warning_failures INT NOT NULL DEFAULT 0,
    info_failures INT NOT NULL DEFAULT 0,

    -- Execution metadata (optional)
    execution_stats JSONB  -- timing breakdown, tiers used, etc.
);

CREATE INDEX idx_kontra_runs_contract_time
    ON kontra_runs (contract_fingerprint, run_at DESC);

CREATE INDEX idx_kontra_runs_passed
    ON kontra_runs (contract_fingerprint, passed, run_at DESC);
```

#### Table: `kontra_rule_results`

Per-rule results. N rows per run (one per rule).

```sql
CREATE TABLE kontra_rule_results (
    id SERIAL PRIMARY KEY,
    run_id INT NOT NULL REFERENCES kontra_runs(id) ON DELETE CASCADE,

    -- Rule identity
    rule_id TEXT NOT NULL,      -- e.g., "COL:email:not_null"
    rule_name TEXT NOT NULL,    -- e.g., "not_null"

    -- Result
    passed BOOLEAN NOT NULL,
    failed_count BIGINT NOT NULL DEFAULT 0,

    -- Metadata
    severity TEXT NOT NULL,     -- "blocking" | "warning" | "info"
    message TEXT,               -- human-readable result message
    column_name TEXT,           -- nullable, not all rules are column-scoped

    -- Variable structure (still JSONB)
    details JSONB,              -- rule-specific failure details
    context JSONB,              -- user-defined context from contract
    samples JSONB               -- sample failing rows
);

CREATE INDEX idx_kontra_rule_results_run
    ON kontra_rule_results (run_id);

CREATE INDEX idx_kontra_rule_results_rule_id
    ON kontra_rule_results (rule_id, run_id DESC);

CREATE INDEX idx_kontra_rule_results_failed
    ON kontra_rule_results (rule_id, passed, run_id DESC)
    WHERE NOT passed;
```

**What stays JSONB:**
- `details` — variable per rule type (expected values, ranges, etc.)
- `context` — user-defined, arbitrary structure
- `samples` — variable structure (row data)
- `execution_stats` — optional timing/debugging info

These are genuinely variable-structure data where JSONB is appropriate.

### Migration Strategy

Clean break. New tables, fresh start. Old `kontra_state` data not migrated. Users can re-run validations to rebuild history if needed.

---

## Part 2: Run Annotations

### Purpose

Allow agents and humans to record context about validation runs:
- "This failed because Kafka schema drifted"
- "Fixed by backfilling 2024-01-11"
- "False positive, data is actually valid"
- "Acknowledged, will fix next sprint"

**Critical invariant:** Kontra NEVER reads annotations during validation or diff.

### Table: `kontra_annotations`

```sql
CREATE TABLE kontra_annotations (
    id SERIAL PRIMARY KEY,

    -- What this annotates
    run_id INT NOT NULL REFERENCES kontra_runs(id) ON DELETE CASCADE,
    rule_result_id INT REFERENCES kontra_rule_results(id) ON DELETE CASCADE,
    -- rule_result_id is NULL for run-level annotations

    -- Who created it
    actor_type TEXT NOT NULL,   -- "agent" | "human" | "system"
    actor_id TEXT NOT NULL,     -- e.g., "repair-agent-v2", "alice@example.com"

    -- What it says
    annotation_type TEXT NOT NULL,  -- uninterpreted by Kontra
    summary TEXT NOT NULL,          -- human-readable summary
    payload JSONB,                  -- arbitrary structured data

    -- When
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_kontra_annotations_run
    ON kontra_annotations (run_id);

CREATE INDEX idx_kontra_annotations_rule
    ON kontra_annotations (rule_result_id)
    WHERE rule_result_id IS NOT NULL;

CREATE INDEX idx_kontra_annotations_time
    ON kontra_annotations (created_at DESC);
```

### Semantics

- **Append-only:** No update, no delete, no overwrite
- **Uninterpreted:** Kontra stores `annotation_type` but doesn't define vocabulary
- **Opt-in reads:** Annotations never appear unless explicitly requested

### Common `annotation_type` values (suggested, not enforced)

| Type | Meaning |
|------|---------|
| `resolution` | "I fixed this" |
| `root_cause` | "This failed because..." |
| `false_positive` | "This isn't actually a problem" |
| `acknowledged` | "I saw this, will address later" |
| `suppressed` | "Intentionally ignoring this" |
| `note` | General comment |

Consumers define their own vocabulary. Kontra doesn't care.

---

## Part 3: Python API

### Writing Annotations

```python
import kontra

# After a validation run
result = kontra.validate("data.parquet", "contract.yml")

# Annotate the run
kontra.annotate(
    run=result,  # or run_id, or contract + "latest"
    actor_type="agent",
    actor_id="repair-agent-v2",
    annotation_type="resolution",
    summary="Root cause was Kafka schema drift",
    payload={
        "fix": "backfilled 2024-01-11",
        "columns_affected": ["email", "status"],
    }
)

# Annotate a specific rule
kontra.annotate(
    run=result,
    rule_id="COL:email:not_null",
    actor_type="agent",
    actor_id="repair-agent-v2",
    annotation_type="root_cause",
    summary="Upstream system sends nulls for inactive users",
)
```

### Reading Annotations

```python
# Get run with annotations
run = kontra.get_run("users_contract", include_annotations=True)
run.annotations  # list of run-level annotations

# Get annotations for a specific rule
for rule in run.rules:
    if rule.annotations:
        print(f"{rule.rule_id}: {len(rule.annotations)} annotations")

# Or query directly
annotations = kontra.get_annotations(
    contract="users_contract",
    rule_id="COL:email:not_null",  # optional filter
    since="7d",                     # optional time filter
)
```

### API Ergonomics

```python
# Option 1: Pass result object directly
kontra.annotate(run=result, ...)

# Option 2: Pass contract name (annotates latest run)
kontra.annotate(contract="users_contract", ...)

# Option 3: Pass specific run_id
kontra.annotate(run_id=123, ...)
```

Recommendation: Support all three. Most common case is "annotate the run I just did."

### Integration with Existing APIs

```python
# list_runs — opt-in annotation loading
runs = kontra.list_runs("users_contract", include_annotations=False)  # default
runs = kontra.list_runs("users_contract", include_annotations=True)

# get_run — opt-in annotation loading
run = kontra.get_run("users_contract")  # no annotations
run = kontra.get_run("users_contract", include_annotations=True)

# diff — annotations NEVER included by default
diff = kontra.diff("users_contract")  # no annotations

# to_llm — opt-in annotation summary
result.to_llm()  # no annotations
result.to_llm(include_annotations=True, max_annotations=3)
```

---

## Part 4: SQL Server Backend (New)

SQL Server state backend currently doesn't exist. Adding it as part of this release.

### Table: `kontra_runs` (SQL Server)

```sql
CREATE TABLE kontra_runs (
    id INT IDENTITY(1,1) PRIMARY KEY,

    -- Identity
    contract_fingerprint NVARCHAR(255) NOT NULL,
    contract_name NVARCHAR(255) NOT NULL,
    dataset_fingerprint NVARCHAR(255),
    dataset_name NVARCHAR(500),

    -- Timing
    run_at DATETIMEOFFSET NOT NULL,
    duration_ms INT,

    -- Summary
    passed BIT NOT NULL,
    total_rows BIGINT,
    total_rules INT NOT NULL,
    passed_rules INT NOT NULL,
    failed_rules INT NOT NULL,

    -- By severity
    blocking_failures INT NOT NULL DEFAULT 0,
    warning_failures INT NOT NULL DEFAULT 0,
    info_failures INT NOT NULL DEFAULT 0,

    -- Execution metadata
    execution_stats NVARCHAR(MAX)  -- JSON string (SQL Server 2016+)
);

CREATE INDEX idx_kontra_runs_contract_time
    ON kontra_runs (contract_fingerprint, run_at DESC);
```

### Table: `kontra_rule_results` (SQL Server)

```sql
CREATE TABLE kontra_rule_results (
    id INT IDENTITY(1,1) PRIMARY KEY,
    run_id INT NOT NULL REFERENCES kontra_runs(id) ON DELETE CASCADE,

    rule_id NVARCHAR(255) NOT NULL,
    rule_name NVARCHAR(100) NOT NULL,

    passed BIT NOT NULL,
    failed_count BIGINT NOT NULL DEFAULT 0,

    severity NVARCHAR(20) NOT NULL,
    message NVARCHAR(MAX),
    column_name NVARCHAR(255),

    details NVARCHAR(MAX),   -- JSON string
    context NVARCHAR(MAX),   -- JSON string
    samples NVARCHAR(MAX)    -- JSON string
);

CREATE INDEX idx_kontra_rule_results_run
    ON kontra_rule_results (run_id);

CREATE INDEX idx_kontra_rule_results_rule_id
    ON kontra_rule_results (rule_id, run_id DESC);
```

### Table: `kontra_annotations` (SQL Server)

```sql
CREATE TABLE kontra_annotations (
    id INT IDENTITY(1,1) PRIMARY KEY,

    run_id INT NOT NULL REFERENCES kontra_runs(id) ON DELETE CASCADE,
    rule_result_id INT REFERENCES kontra_rule_results(id) ON DELETE CASCADE,

    actor_type NVARCHAR(50) NOT NULL,
    actor_id NVARCHAR(255) NOT NULL,

    annotation_type NVARCHAR(100) NOT NULL,
    summary NVARCHAR(MAX) NOT NULL,
    payload NVARCHAR(MAX),  -- JSON string

    created_at DATETIMEOFFSET NOT NULL DEFAULT SYSDATETIMEOFFSET()
);

CREATE INDEX idx_kontra_annotations_run
    ON kontra_annotations (run_id);

CREATE INDEX idx_kontra_annotations_rule
    ON kontra_annotations (rule_result_id)
    WHERE rule_result_id IS NOT NULL;
```

**SQL Server notes:**
- Uses `NVARCHAR(MAX)` for JSON (no native JSONB like PostgreSQL)
- Uses `BIT` instead of `BOOLEAN`
- Uses `DATETIMEOFFSET` for timezone-aware timestamps
- Uses `IDENTITY(1,1)` instead of `SERIAL`

---

## Part 5: File-Based Backends (S3, Local)

### S3 Backend

```
s3://bucket/kontra-state/
  <contract_fingerprint>/
    runs/
      <run_id>.json           # run metadata + rule results
    annotations/
      <run_id>.jsonl          # append-only annotations
```

Annotation file format (JSONL):
```json
{"id": 1, "rule_result_id": null, "actor_type": "agent", "actor_id": "...", "annotation_type": "resolution", "summary": "...", "payload": {...}, "created_at": "..."}
{"id": 2, "rule_result_id": 45, "actor_type": "human", "actor_id": "...", "annotation_type": "note", "summary": "...", "payload": null, "created_at": "..."}
```

### Local Backend

```
.kontra/state/
  <contract_fingerprint>/
    runs/
      <run_id>.json
    annotations/
      <run_id>.jsonl
```

Same format as S3.

---

## Part 5: Implementation Plan

### Phase 1: Schema & Core Types
- [ ] Define new table DDLs (PostgreSQL, SQL Server)
- [ ] Define new file formats (S3, local)
- [ ] Add `Annotation` dataclass
- [ ] Update state types

### Phase 2: Backend Implementation
- [ ] PostgreSQL: Full implementation with new schema
- [ ] SQL Server: New backend (doesn't exist today)
- [ ] Local: Update to new file format
- [ ] S3: Update to new file format

### Phase 3: Core API
- [ ] Update `ValidationResult` to work with new schema
- [ ] Implement `kontra.annotate()`
- [ ] Implement annotation loading in `get_run()`, `list_runs()`
- [ ] Ensure backwards compatibility in Python API

### Phase 4: Integration
- [ ] Update `to_dict()` / `to_json()` for annotations
- [ ] Add `to_llm()` annotation support (opt-in)
- [ ] CLI: `kontra annotate` command (optional)

### Phase 5: Testing & Docs
- [ ] Unit tests for annotation CRUD
- [ ] Integration tests across backends
- [ ] Update state-and-diff.md
- [ ] Update agents-and-llms.md
- [ ] Add annotation examples

---

## Part 6: Invariants (Must Hold)

1. **Annotations are append-only.** No update, no delete.

2. **Kontra never reads annotations during validation.** Validation results are identical whether annotations exist or not.

3. **Kontra never reads annotations during diff.** Diff compares measurements only.

4. **Annotations are opt-in for reads.** Default is to not load them.

5. **Annotation vocabulary is uninterpreted.** Kontra stores `annotation_type` but doesn't define or validate the values.

6. **Annotations cascade delete with runs.** If a run is deleted, its annotations are deleted.

---

## Part 7: Open Questions

1. **Should `annotation_type` be constrained?**
   - Current: Free text, uninterpreted
   - Alternative: Enum with extensibility
   - Recommendation: Keep free text, document common patterns

2. **Should annotations have edit/delete?**
   - Current: Append-only
   - Alternative: Allow soft-delete (mark as deleted, don't remove)
   - Recommendation: Keep append-only for v0.5, revisit if needed

3. **Should CLI have `kontra annotate` command?**
   - Useful for humans, less useful for agents
   - Could defer to v0.6
   - Recommendation: Include basic CLI command

4. **Run ID format for non-SQL backends?**
   - Options: UUID, timestamp, sequential
   - Recommendation: ISO timestamp + random suffix (e.g., `2024-01-15T09:30:00Z_a1b2c3`)

---

## Part 8: Success Criteria

- [ ] Validation runs stored in normalized tables
- [ ] Rule results queryable by `rule_id` across runs
- [ ] Annotations can be written and read
- [ ] Annotations never affect validation or diff
- [ ] All four backends work:
  - [ ] PostgreSQL
  - [ ] SQL Server (new)
  - [ ] S3
  - [ ] Local
- [ ] Existing tests pass
- [ ] New tests for annotation functionality
- [ ] New tests for SQL Server backend
- [ ] Documentation updated
